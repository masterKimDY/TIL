# 객체지향사실과 오해 - 조영호

### 행동이 상태를 결정한다.
 - 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는것이다. 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.
 - 1. 상태를 먼저 결정할 경우 캡슐화가 저해된다 : 상태가 객체내부로 깔금하게 캡슐화되지 못하고 공용 인터페이스에 노출되버릴 확률이 높음.
 - 2. 객체를 협력자가 아닌 고립된 섬으로 만든다 : 애플리케이션 문맥내에서 다른 객체와 협력하기 위해서는 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀어진다.
 - 3. 객체의 재사용성이 저하된다. : 객체의 재사용성은 다양한 협력에 참여할수있는 능력에서 나온다, 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵다.

 - 상태가아닌 행동에 초점을 맞춘다. : 객체는 다른객체와 협력하기 위해 존재함. 협력의 문맥에 맞는 적절한 행동을 수행하는 객체를 발견하거나 창조해야한다.
 - 행동을 결정하고 행동에 필요한 정보가 무엇인지를 고려하라 이 과정에서 상태가 결정된다.
 - 협력안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다.
 - 협력이란 문맥안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게한다.


### 은유와 객체
 - `객체지향이란 현실 세계의 모방?` : 객체지향 세계는 현실 세계의 단순한 모방이 아니다.
 - 모방과 추상화라는 개념만으로는 현실 객체와 소프트웨어 객체 사이의 관계를 깔끔하게 설명하지 못함.
 - 의인화 : 현실에서는 수동적인 존재가 객체로 구현횔 때는 능동적으로 변한다.
 - 소프트웨어 객체가 현실 객체의 부분적인 특정을 모방하는 것이 아니라 현실 객체가 가지지 못한 추가적인 능력을 보유하게 된다.
 - `소프트웨어 안에 구축되는 객체지향 세계는 현실을 모방한것이 아니다.` 현실의 모습을 조금 참조할 뿐 궁금적인 목적은 현실과 전혀 다른 새로운 세계를 창조한다.
 - 객체지향 세계에서는 현실속의 객체보다 더 많은 특징과 능력을 보유한 객체들로 넘쳐난다.

 - 은유 (metaphor): 현실속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다.
 - 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름을 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측가능하다.
 - 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄이며, 이해하기 쉽고 유지보수가 용이한 개발이 가능하다.
 - 그리서 현실세계의 도메인에서 사용되는 이름을 객체에게 부여하라고 하는것이다.
 - 현실속의 객체의 이름을 이용해 객체를 묘사하고 그렇지 않으면 깔끔하게 현실을 무시하고 자유롭게 새로운 세계를 창조하라

### 타입과 추상화
 - 추상화를 통한 복잡성 극복 : 인간이 지니고 있는 인지능력과 저장공간은 보잘것없다, 따라서 사람들은 본증적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화하는 전략을 따른다.
 - 추상화의 목적은 불필요한 부분을 무시하고 현실에 존재하는 복잡성을 극복한다. 복잡한 현실을 단순화하기 위해서는 인간의 가장 기본적인 인지수단이라고 할 수 있음.
 - 어떤 추상화도 의도된 목적이 아닌 다른 목적으로 사용된다면 잘못된 길로 갈 수 있다.
 - 추상화의 수준 이익 가치는 목적에 의존적이다. 현상은 복잡하고 법칙은 단순하고 버릴게 무엇인지 알아내야한다.
 - 1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만든다.
 - 2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만든다.

### 객체지향과 추상화
 - 그룹으로 나누어 단순화하기 : 명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물을 객체지향에서는 객체라고 한다.
 - 개념 : 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트왕, 하트왕비 : 걍 트럼프 (차이점을 무시하고 공통점만 뽑아서 추상화)
 - 구체적이고 실제적인 객체가 존재하지만 수많은 객체들을 개별적인 단위로 취급하기에는 인지능력이 부족하다, 공통적인 특성을 기준으로 객체를 여러 그룹으로 묶어 동시에 다뤄야하는 가짓수를 줄이고 상황을 단순화하려해야함.
 - 공통점을 기반으로 객체묶기 (개념 concept): 개념을 이용하면 객체를 여러 그룹으로 분류(classification) 할 수있다.
 - 개념은 공통점을 기반으로 객체를 분류할 수 있는 일종의 객체
 - 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일월이 될 때 객체를 그 개념의 인스턴스(instance)라고 한다.
 - 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미하며, 개념이 객체에 적용되면 객체를 개념의 인스턴스라고 한다.

### 개념의 관점
 - 심볼 : 개념을 가르키는 간략한 이름이나 명칭 (예제에서는 트럼프)
 - 내연 : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인 가능 (내연이란 개념의 의미 몸이 납작하고 두 손과 두발이 네모난 몸모서리에 달려있는...)
 - 외연 : 개념에 속하는 모든 객체의 집합 (set) (개념에 속하는 객체들, 개념의 인스턴들이 모여 이뤄진 집합)
 - 개념을 구성하는 심볼 내연 외연은 객체의 분류 방식에 대한 지침을 제공한다, 개념을 이용해 객체를 분류 할 수있다.
 - `개념을 이용해 공통점을 가진 객체들을 분류할 수있다는 아이디어는 객체지향의 복잡성을 극복하는데 사용하는 가장 기본적인 인지 수단이다.`
 - 객체지향의 세계에서는 클래스가 분류라는 개념이 얼머나 중요한지 실감 (객체를 분류하기 위한 틀)

### 분류
 - 분류란 객체에 특정한 개념을 적용하는 작업, 객채에 특정한 개념을 적용하기로 했으면 그 객체를 특정한 집합의 멤버로 분류하고 있는것임.
 - 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.
 - 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구이다.

### 타입 (type)
 - 타입은 개념이다 : 타읍은 공통점을 기반으로 객체들을 묶기 위한 틀이다. 타입은 개념과 마찬가지로 심볼,내연,외연을 이용해 서술 할 수있으며 타입에 속하는 객체 역시 타입의 인스턴스라고 한다.
 - 데이터 타입 : 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다.
 - 1. 타입은 데이터가 어떻게 사용되느냐 따라서 데이터가 어떤 타입에 속하는지 결정하는 것은 데이터에 적용할 수 있는 작업이다. 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 데이터의 타입을 결정한다.
 - 2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지 외부로부터 철저하게 감춰진다.
 - 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는데 사용하는 메모리 집합에 관한 메타데이터이다.
 - 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

### 객체와 타입
 - 객체를 일종의 데이터 처럼 사용한다 따라서 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다.
 - 모든 객체의 상태를 모으면 결국 애플리케이션에서 관리해야하는 전체 데이터를 표현할 수 있다.
 - 객체는 데이터가 아니다 객체에서 중요한것은 행동이며 상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일뿐
 - 객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야 할지를 결정하는것이다. 객체가 협을 위해 어떤 책임을 지녀야 하는지를 결정하는것이 객체지향의 설계의 핵심
 - 1. 어떤 객체가 어떤 타입에 속하는지를 결정하는것은 객체가 수행하는 행동이다. 어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될수있다.
 - 2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 객체의 행동을 가장 효과적으로 수행할 수만있다면 내부상태를 어떤방식으로 표현하더라도 무방함

### 행동이 우선
 - 동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속한다. 이것이 객체를 타입으로 분류할때 사용해야하는 기준을 명확하게 제시해준다.
 - 객체의 타입을 결정하는것은 행동뿐이며, 어떤 데이터를 보유하고 있는지는 타입을 결정하는데 어떤 영향도 미치지 않는다.
 - 여기서의 동일한 행동이란 동일한 책임을 의미하며, 동일한 책임이란 동일한 메시지 수신을 의미한다. (다형성)
 - 다형성이란 메시지를 서로 다른 방슥으로 처리하기 위해서는 객체들은 동일한 메시지를 수신할 수 있어야 하기 때문에 결과적으로 다형적인 객체들은 동일한 타입(또는 타입계층)에 속하게 된다.
 - 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춘다 (캡슐화 인포메이션 하이딩?)
 - 행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관해야하는 데이터가 아니라 `객체가 외부에 제공해야 하는 행동`을 먼저 생각해야 한다.
 - 이를 위해서는 객체가 외부에 제공해야하는 책임을 먼저 결정하고 그 책임을 수행하는데 적합한 데이터를 나중에 결정한 후 데이터를 책임을 수행하는 데 필요한 외부 인터페이스 뒤로 캡슐화 한다.
 - 데이터를 먼저 결정하고 객체의 책임을 결정하는 방법은 유연하지 못한 설계이다. (데이터 주도 설계) <-> (책임(객체)주도 설계)

### 타입의 계층
 - 객체가 동일한 타입으로 분류되기 위해서는 공통의 행동을 가져야만 한다.
 - 트럼프 인간타입의 외연은 트럼프 타입의 외연의 부분집합이며, 트럼프는 트럼프인간을 포괄하는 좀 더 일반적인 개념이다.
 - 트럼프 인간은 트럼프보다 좀 더 특화된 행동을 하는 특스한 개념이며, 두 개념 사이의 관계를 `일반화/특수화` 관계라고 한다.
 - 일반화/특수화 : 트럼프는 트럼프 인간보다 더 일반적인 개념이며, 더 일반적이라는 말은 더 포괄적이라는 의미를 내표하기 때문에 트럼프는 트럼프 인간에 속하는 객체를 포함한다.
 - 일반화와 특수화는 동시에 일어나며 트럼프인간은 트럼프를 좀 더 특수하게 표현한것이다. 특수하다는 것은 일반적인 개념보다 범위가 더 좁다는 것을 의미
 - 어떤 객체가 다른 객체보다 더 일반적인 상태를 표현하거나 더 특수한 상태를 표현한다고 해서 두 객체가 속하는 타입관계 일반화/특수화 관계가 성립하는것은 아니다. (외부에 제공하는 행동이 중요)
 - 특수한 타입이란 일반적인 타입이 가진 모든 타입을 포함하지만 거기에 더해 자신만의 행동을 추가하는 타입을 가르킨다.
 - 일반화/특수화는 행동에 관한 것이며, 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있어야한다.
 - 타입의 내연을 의미하는 행동의 가짓수와 외연을 의미하는 집합의 크기는 서로 반대다. (일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지지만 집합의 크기는 더 크다.)
 - 일반적인 타입을 슈퍼타입, 좀 더 특수한 타입을 서브타입이라고 함. (서브타입이 되려면 행위적 호환성을 만족시켜야 한다.) 서브타입은 슈퍼타입을 대체 가능
 - 따라서 어떤 타입을 다른 타입의 서브타입이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야한다 (리스코프 치환원칙)

### 일반화는 추상화를 위한 도구이다.
 - `중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만든다.`
 - 객체지향 패러다임을 통해 세상을 바라보는 거의 대부분 경우에 분류와 일반화/특수화 기법을 동시에 적용한다. (일반적인 상황에서는 슈퍼타입, 특수한상황에서는 특수한 서브타입)

### 정적모델
 - 타입의 목적 : 객체지향에서는 객체를 지향하는데 객체만 다루면되지 타입을 사용하는 이유는?
 - 인간의 인지능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵다.
 - 행동에 따라 상태는 계속변한다. 상태는 변하지만 식별성은 동일하게 유지되고, 동적으로 변하는 상태와 무관하게 타입은 그대로 유지된다. 그래서 결국 타입은 추상화다.
 - 타입을 이용하면 객체의 동적인 특성을 추상화 할 수 있다. 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화 할 수있는 효과적인 방법인것

### 클래스
 - oop언어에서 정적인 모델은 클래스를 이용해 구현된다. 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것
 - 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일뿐
 - 클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 클래스를 타입과 동일시하면 오해와 혼란을 불러일으키곤 한다.
 - `객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이라는 사실 (제일중요)`

### 역할 책임 협력
 - 협력이라는 문맥을 고려하고 객체가 가져야할 행동과 상태를 고민하자 중요한것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력이다.
 - 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.

### 협력 (요청하고 응답하며 협력하는 사람들)
 - 협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다. 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.

### 책임 
 - 어떤 객체가 어떤 요청에 대해 대답해 줄수있거나 적절한 행동을 할 의무가 있는 경우 해당 겍체가 `책임`을 가진다고 말한다.
 - 객체지향 개발에서 책임을 능숭하게 소프트웨어 객체에 할당하는것이 중요항 능력
 - 객체와 책임이 이지저리 떠다디는 상황에서 성급하게 구현에 뛰어드는 것은 변경에 취약하고 다양항 협력에 참여할 수 없는 비자율적 객체를 낳는다.
 - 책임은 객체에 정의되는 응집도 있는 행위의 집합, 객체가 알아야하는 정보와 객체가 수행할 수 있는 행위에 대해 개략적으로 서술한 문장이다.
 - 객체의 책임은 객체가 `무엇을 알고있는가`, `무엇을 할 수 있는가`
 - 하는것: 객체를 생성하거나 계산하는등의 스스로하는것, 다른 객체의 행동을 시작시키는것, 다른 객체의 활동을 제어하고 조절하는것
 - 아는것: 개인적인 정보에 관해 아는것, 관련된 객체에 관해 아는것, 자신이 유도하거나 계산할수 있는 것에 관해 아는것
 - `명확한 책임이 애플리케이션의 미래를 결정 짓는다.`
 - 객체의 책임은 공용 인터페이스를 구성한다. (캡슐화해야함)
 
### 책임과 메시지
 - 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 `메시지 전송`이라고 한다. (두 객체간의 협력은 메시지를 통해 이뤄진다.)
 - 주의할점 책임과 메시지의 수준이 같지는 않다. 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로 부터 메시지를 수신할것인지를 결정하는것부터 시작.
 - 어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후 시작해도 늦지 않음.

### 역할
 - 책임의 집합이 의미하는 것 (역할은 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이다)
 - 역할(role)을 사용하면 몇가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다.
 - 역할은 협력 내에서 다른 객체로 대채할 수 있음을 나타내는 일종의 표식이다. 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있습니다.
 - 역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야한다. 메시지 = 책임
 - 동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기 때문에 동일한 책임을 수행 할 수 있다.
 - `단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다.`

### 협력의 추상화
 - 협력의 추상화는 설계자가 다뤄야 하는 협력의 개수를 줄이는 동시에 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화한다.
 - 추상적인 역할을 대체해서 동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있는 능력 -> 객체지향의 힘

### 대체 가능성
 - 역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자.
 - 객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다, 결국 객체는 협력안에서 역할이 수행할 수 있는 행동을 그대로 수행할 수 있어야 한다.
 - 역할이 협력을 추상적으로 만둘 수 있는 이유는 역할자체가 객체의 추상화이기 때문이다.
 - 역할의 대체 가능성은 행위 호환성을 의미하고 행위호환성은 동일한 책임의 수행을 의미한다.

### 객체의 모양을 결정하는 협력
 - 흔한오류 : 시스템에 필요한 데이터를 저장하기 위해 겍체가 존재한다? 데이터는 단지 객체가 행위를 수행하는데 필요한 재료일뿐 실제중요한건 행동 ->책임
 - 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을둔다? 협력에 참여하는 동적인 객체이며 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공해주는 매커니즘일뿐

### 협력을 따라 흐르는 객체의 책임
 - 협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한 다는 것을 의미
 - 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 된다.
 - 클래스와 데이터는 협력과 책임의 집합이 결정된 후에야 무대 위로 등장할 수 있다.
 - 협력이라는 견고한 문맥이 갖춰지면 초점은 협력을 위해 필요한 책임의 흐름으로 옮겨진다. 그리고 협력에 필요한 책임을 결정하고 객체에게 책임을 할당하는 과정
 - 각 객체가 가져야 하는 상태와 행위에 대해 고민전에 그 객체가 `참여할 문맥인 협력을 정의하라` 충분히 자율적인 동시에 충분히 협력적인 객체를 창조해라
 - 객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서 객체를 충분히 자율적으로 만드는것.

### 객체지향 설계 기법
 - 책임 주도 설계 (Responsibility Driven Design) 
 - 디자인패턴 (Design Pattern)
 - 테스트 주도 개발 (Test Driven Devlelopment)