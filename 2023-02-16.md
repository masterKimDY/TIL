# 자바의정성

### package와 import
- 클래스의 묶음이다. 패키지에는 클래스 또는 인터페이스를포함 시킬수 있다.
- 클래스가 물리적으로 하나의 클래스파일인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.
```text
 - 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
 - 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
 - 패키지는 점(.)을 구분자로 하여 계층구조로 구성할수있다.
 - 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉토리이다.
```

- 패키지 선언 : package 패키지명;
- javac -d . PackageTest.java : -d옵션 뒤에는 해당 패키지의 루트 디렉터리의 경로를 적어준다.
- 컴파일러가 패키지의 계층구조에 맞게 새로 디렉토리를 생성하고 컴파일된 클래스파일을 생성한다.
- 클래스패스 (classpath): 컴파일러나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로이다.
- -cp 옵션으로 일시적으로 클래스패스를 지정해 줄 수도 있다.

### 제어자 (modifier)
 - 접근 제어자 : public, protected, default, private
 - 그 외 : static, final, abstract, native, transient, syschronized, volatile, strictfp


### static - 공통적인
 - static이 붙은 멤버변수, 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.

### final
 - 클래스 : 상속불가
 - 메서드 : 오버라이딩 불가
 - 멤버변수 : 할당이후 재할당 불가 / final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자를 통해서 초기화한다.
 - 지역번수 : 할당이후 재할당 불가

### abstract
 - 클래스 : 클래스내에 추상 메서드가 선언되어 있음
 - 메서드 : 추상메서드는 선언부만 작성하고 구현부는 하위클래스에서 해당 기능을 구현해야함.

### 접근 제어자 (access modifier)
 - 멤버 또는 클래스에 사용되어 해당 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
 - private : 같은 클래스 이외 접근불가
 - default : 같은패키지내
 - protected : 같은패키지내, 다른패키지의 하위 클래스에서 접근가능
 - pulbic : 제한없음
 - 클래스 : public, default
 - 메서드, 멤버변수 : 전부 사용가능
 - 지역변수 : 없음
 - 외부로부터 데이터를 보호하기위해 / 외부에 불필요한, 내부적으로만 사용하는 부분을 감추기 위해
 - 생성자가 private면 다른 클래스에서 상속불가 : 해당클래스에서 조상클래스의 생성자를 호출해야하는데 호출할수가 없다.

### 다형성 (polymorphism)
 - 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록함 (자식클래스 인스턴서를 부모클래스 참조변수가 참조가능)
 - 인스턴스를 같은 타입의 참조변수로 참조하는 것과 조상타입의 참조변수로 참조하는 것은 어떤차이가 있을까
 - `둘다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다` 부모타입으로 참조하면 부모타입에 멤버만 사용가능
 - 부모타입으로 생성한 인스턴스를 자식타입으로 참조는 불가

### 참조변수의 형변환
 - 서로 상속관계에 있는 클래스사이에서만 가능 : 하위타입의 참조변수를 상위타입의 참조변수로, 상위타입의 참조변수를 하위타입의 참조변수로 형변환만
 - 기본형 변수의 형변환에서 작은 자료형에서 -> 큰 자료형의 형변환은 생략이 가능하듯이, 
참조형 변수의 형변환에서는 하위타입의 참조변수를 상위타입으로 형변환하는 경우에는 생략가능.
 - 하위타입 -> 상위타입 : 형변환 생략가능 업케스팅
 - 상위타입 -> 하위타입 : 형변환 생략불가 다운케스팅
 - `형변환은 참조변수의 타입을 변환하는 것이지` 인스턴스를 변환하는 것은 아니다 참조변수의 형변환은 인스턴스에 아무런 영향이 없다.
 - `단지 참조변수를 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할수 있는 멤버의 범위를 조절하는 것뿐이다.`
 - 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭다 : 참조변수가 가르키는 인스턴스의 자손타입으로는 형변환은 불가하다.
 - 그리서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.

### instanceof 연산자
 - 참조변수 instanceof 클래스타입 : true, false 참이면 형변환이 가능함.
 
```java
        Tv test = new Tv(false, "테스트", 1);
        Object test1 = test;    //형변환 생략가능
        Tv test11 = (Tv) test1; // 상위타입 -> 하위타입으로 
```


### 참조변수와 인스턴스의 연결
 - 상위타입으로 참조변수로 연결된 하위 인스턴스가 있을때 오버라이딩된 메서드가 실행되지만, 참조변수는 그렇지 않다.
 - 동일한 이름의 멤버변수의 경우 참조변수의 타입에 따라 달라진다.
 - static 메소드는 static변수처럼 참조변수의 타입에 영향을 받는다. 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드뿐이다. 그래서 static메서드는 반드시 참조변수가 아닌 클래스이름.메서드()로 호출해야한다.

### 매개변수의 다형성
 - 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.
 - 메서드에 매개변수에 다형석을 적용하면 상위타입으로 받을수있다. (하위타입까지 모두 포함하므로)

### 추상클래스 (abstract class)
 - abstract 메소드가 있으면 클래스에도 abstract 
 - 추상메서드를 포함하고 있지 않는 클래스에도 abstract를 붙여서 추상클래스로 지정할수도 있음. 추상클래스로 지정되면 인스턴스를 생성할 수 없다.
 - 메서드 몸통은 없고 선언부만있다. 실제내용은 하위클래스에서 정의한다.
 - 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업 
 - 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

### 인터페이스 (interface)
 - 인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높다.
 - 오직 추상메서드와 상수만을 멤버로 가질 수 있다. 
 - 모든 멤버변수는 public static final 이여야 한다. (생략가능)
 - 모든 메서드는 public abstract 이어야한다. (생략가능) static메서드와 default메서드는 예외 (java8)

### 인터페이스의 상속
 - 인터페이스는 인터페이스로부터만 상속받을 수 있다. 클래스와는 달리 다중상속, 즉 여러개의 인터페이스로부터 상속을 받는 것이 가능하다.

### 인터페이스의 구현 (implements)
 - 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼, 인터페이스도 자신에 정의된 추상 메서드의 몸통을 만들어주는 클래스를 작성해야한다.
 - 구현하는 인터페이스의 메서드 중 일부만 구현한다면 abstract를 붙여서 추상클래스로 선언해야 한다.
 - 상속과 구현을 동시에 할 수도 있다.

### 인터페이스를 이용한 다중상속
 - 인터페이스는 static 상수만 정의할 수 있으므로 상위클래스의 멤버변수가 충돌하는 경우는 없다 있다하더라도 static 변수니 클래스이름을 붙여서 구분 가능

### 인터페이스를 이용한 다형성
 - 다형성중에 하위클래스의 인스턴스를 상위타입의 참조변수로 참조하는것이 가능하다.
 - 인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조 할 수 있다. 인터페이스 타입으로 형변환도 가능하다.
 - 매개변수를 인터페이스 타입으로 받을수도 있다. 해당 메소드 호출시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다.
 - 메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것 역시 가능.
 - 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.

### 인터페이스의 장점
 - 개발 시간을 단축 시킬수있다
 - 표준화가 가능하다
 - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다 
 - 독립적인 프로그래밍이 가능하다

### 인터페이스의 이해
 - 클래스를 사용하는쪽 클라이언트와 클래스를 제공하는쪽 서버가 있다.
 - 메서드를 사용 호출하는쪽 클라이언트에서는 사용하려는 메서드의 선언부만 알면된다. (내용은 몰라도 된다.)
 - 두 클래스간의 관계를 간접적으로 변경하기 위해서는 인터페이스를 이용해서 클래스의 선언과 구현을 분리한다.
 - A -> B (인터페이스 호출)

### 디폴트 메서드와 static 메서드
 - 자바8부터 가능
 - 인터페이스의 static메서드역시 접근제어제가 항상 public이다.
 - static 메서드 : java.util.Collection -> java.util.Collections 참고
 - default 메서드 : 인터페이스에 메서드를 추가하면 이 인터페이스를 구현한 기존의 모든 클래스에 추가된 메서드를 구현해야한다. 그리서 디폴트 메서드가 나왔다.
 - 디폴트 메서드는 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않는다. 메서드 몸통이 있어야한다.
 - 이름이 충돌하는 경우
  - 여러 인터페이스의 디폴트 메서드 간의 충돌 : 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야 한다.
  - 디폴트 메서드와 조상 클래스의 메서드 간의 충돌 : 조상 클래스의 메서드가 상속되고 디폴트 메서드는 무시된다.
  - 그냥 필요한 쪽의 메서드와 같은 내용으로 오버라이딩 해버린다?

### 내부 클래스 (inner class)
 - 내부 클래스는 클래스 내에 선언된다. 일반적인 클래스와 같다.
 - 내부클래스는 클래스에 내에 선언된 클래스로 클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다.
 - 한 클래스를 다른 캘르스의 내부 클래스로 선언하면 두 클래스의 멤버들 간에 서로 쉽게 접근 할 수있다. 외부에는 불필요한 클래스를 감춘다.

### 내부 클래스의 종류와 특징
 - 내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다. 내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언 할 수 있다.
 - 인스턴스 클래스 : 외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 인스턴스 멤버처럼 다룬다. 주로 외부 클래스의 인스턴스맴버들과 관련된 작업에 사용
 - 스태틱 클래스 : 외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 static 멤버처럼 다루어진다. 주로 외부 클래스의 static 멤버, 특히 static메서드에서 사용될 목적
 - 지역 클래스 : 외부 클래스의 메서드나 초기화 블럭안에 선언하며, 선언된 영역 내부에서만 사용될수 있다.
 - 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스