# 자바의정석

### java.lang 패키지
java.lang 패키지는 Java 언어에서 가장 기본적이면서도 가장 자주 사용되는 클래스들을 포함하는 패키지입니다. 이 패키지는 자바 프로그래밍을 할 때에는 필수적으로 import 되는 패키지 중 하나입니다.

java.lang 패키지에는 다음과 같은 클래스와 인터페이스가 포함됩니다.

Object: 모든 자바 클래스의 최상위 클래스이며, 자바 객체의 모든 공통 기능을 제공합니다.
Class: 클래스와 인터페이스의 메타데이터를 저장하고, 클래스를 동적으로 로드하고 생성할 수 있는 기능을 제공합니다.
String: 문자열을 다루는 클래스로, 문자열 비교, 검색, 분리, 변경 등 다양한 기능을 제공합니다.
StringBuilder와 StringBuffer: 문자열을 동적으로 조작하는 클래스로, 문자열 추가, 삭제, 변경 등 다양한 기능을 제공합니다.
Throwable: 예외와 오류 클래스의 상위 클래스로, 예외 발생과 관련된 정보를 저장하고 처리하는 기능을 제공합니다.
Exception과 RuntimeException: 예외 클래스의 상위 클래스로, 예외 처리와 관련된 기능을 제공합니다.
Error: 오류 클래스의 상위 클래스로, JVM에서 발생하는 심각한 오류를 처리하는 기능을 제공합니다.
또한, java.lang 패키지에는 자바의 기본 자료형과 관련된 클래스들, 시스템 정보를 다루는 클래스, 스레드와 관련된 클래스 등도 포함되어 있습니다.


### 공변 반환 타입
```text
공변반환 타입(covariant return type)은 자바 5부터 추가된 기능으로, 하위 클래스에서 상위 클래스의 메서드를 오버라이딩할 때, 
반환 타입을 하위 클래스 타입으로 변경할 수 있는 기능을 말합니다.

이 기능은 다형성(polymorphism)을 강화시켜주는데, 다형성이란 객체가 여러 가지 형태를 갖는 것을 의미합니다. 
예를 들어, 상위 클래스인 Animal이 있고 이를 상속한 하위 클래스인 Dog가 있다면, Dog 클래스에서 Animal 클래스의 메서드를 오버라이딩할 때, 
반환 타입을 Animal에서 Dog로 변경할 수 있습니다. 이렇게 하면, Animal 타입으로 선언된 변수에 Dog 객체를 할당할 때, 
Dog 타입으로 반환되는 메서드를 호출할 수 있게 됩니다.

이러한 공변반환 타입은 코드의 가독성을 향상시키고, 불필요한 형변환을 줄일 수 있는 장점이 있습니다. 
다만, 공변반환 타입을 사용할 때에는 메서드 시그니처를 주의해서 작성해야 하며, 타입 안정성을 보장하기 위해 잘못된 사용을 방지하는 제약 사항이 있습니다.

공변반환 타입을 사용할 때에는 다음과 같은 제약 사항이 있습니다.

메서드 시그니처는 반드시 같아야 한다.
오버라이딩을 할 때는 메서드 시그니처가 같아야 하므로, 메서드 이름, 매개변수 타입, 개수, 순서, 접근 제어자, 예외 처리 등 모든 면에서 일치해야 합니다.

반환 타입은 반드시 하위 클래스 타입이어야 한다.
공변반환 타입을 사용할 때는, 반환 타입이 하위 클래스 타입으로만 변경할 수 있으며, 상위 클래스 타입으로 변경할 수 없습니다. 
이를 위반하면 컴파일 오류가 발생합니다.

제네릭 타입에서는 제한이 있다.
자바에서 제네릭 타입에서 공변반환 타입을 사용할 때는, 타입 안정성을 보장하기 위해 몇 가지 제한이 있습니다. 
예를 들어, 배열과 다르게 제네릭 타입은 컴파일 시점에 타입 안정성이 보장됩니다. 
따라서, 공변반환 타입을 사용할 때에는, 타입 안전성을 보장하기 위해 몇 가지 규칙을 지켜야 합니다.

공변반환 타입은 객체지향 프로그래밍에서 다형성을 지원하는 중요한 개념 중 하나입니다. 
상속을 기반으로 하는 다형성의 장점을 살리면서, 코드의 가독성을 향상시킬 수 있는 공변반환 타입은 자바 5부터 지원되며, 자바에서 중요한 개념 중 하나입니다.
```

### 클래스 로더
```text
자바 클래스로더(Class Loader)는 계층 구조로 이루어져 있으며, 각 계층은 다른 클래스 로더를 부모 클래스 로더로 갖습니다. 
부모 클래스 로더가 로딩한 클래스를 자식 클래스 로더도 재사용할 수 있기 때문에, 클래스 로딩과 관련된 성능과 보안을 강화할 수 있습니다. 
일반적으로 자바 클래스로더는 다음과 같은 계층으로 구성됩니다.

부트스트랩 클래스로더 (Bootstrap Class Loader)
부트스트랩 클래스로더는 JVM 내부에서 가장 상위에 위치하는 클래스로더입니다. 
JDK 내부의 rt.jar 파일에 포함된 클래스를 로딩하는 역할을 담당하며, JAVA_HOME/lib 디렉토리에 위치한 다른 jar 파일도 로딩할 수 있습니다.
 부트스트랩 클래스로더는 네이티브(C/C++) 코드로 구현되어 있으며, 클래스 로딩이 실패하면 NoSuchMethodError, NoSuchFieldError 등의 예외를 발생시킵니다.

확장 클래스로더 (Extension Class Loader)
확장 클래스로더는 JAVA_HOME/lib/ext 디렉토리나 java.ext.dirs 시스템 프로퍼티에 지정된 디렉토리에 있는 클래스를 로딩하는 역할을 합니다. 
확장 클래스로더는 부트스트랩 클래스로더의 자식 클래스로더이며, 표준 클래스 로딩 메커니즘과 다르게 클래스 이름을 로드할 때 "java.lang" 패키지 이름이 없는 경우에만 검색합니다.

시스템 클래스로더 (System Class Loader)
시스템 클래스로더는 CLASSPATH 환경 변수나 -classpath 옵션으로 지정된 디렉토리에 있는 클래스를 로딩하는 역할을 합니다. 
시스템 클래스로더는 확장 클래스로더의 자식 클래스로더이며, 애플리케이션에서 직접 사용되는 클래스를 로딩하는 가장 마지막 단계의 클래스로더입니다.

사용자 정의 클래스로더 (Custom Class Loader)
사용자 정의 클래스로더는 개발자가 직접 작성한 클래스 로더입니다. 이 클래스 로더는 다른 클래스 로더를 확장하거나 대체할 수 있으며, 다른 계층의 클래스 로더와 달리 자식 클래스 로더를 가질 수 있습니다.

자바 클래스로더 계층 구조에서는 부모 클래스 로더에서 이미 로딩한 클래스를 자식 클래스 로더에서도 재사용할 수 있으므로, 클래스 로딩과 관련된 성능과 보안을 강화할 수 있습니다. 
하지만 이러한 구조로 인해 각 클래스 로더가 로딩한 클래스는 해당 클래스 로더의 계층 구조 내에서만 사용 가능합니다. 
즉, 클래스 로딩이나 인스턴스화 과정에서 해당 클래스 로더의 부모 클래스 로더가 로딩한 클래스를 사용할 수 있지만, 그 반대는 불가능합니다. 
이를 클래스 로더의 "자체적인 이름 공간(namespaces)"이라고 합니다. 이러한 구조는 각각의 클래스 로더가 사용하는 클래스를 격리시켜 애플리케이션의 보안을 높이는데 큰 역할을 합니다.
```


### String 클래스
 - 변경 불가능한(immutable) 클래스 : 한번 생성된 String 인스턴스가 갖고 있는 문자열은 읽기만 가능하고 변경은 불가하다.
 - String str = "123"; //문자열 리터럴은 클래스가 메모리에 로드될 때 자동적으로 미리 생성된다.
 - 문자열 상수풀 (String Constant Poll) : 리터럴이 저장되는 메모리 공간 JVM이 자동으로 상수풀에 해당 문자열을 저장 이후에 동일한 문자열이 사용될 경우 상수풀에서 값 참조, 
 - 클래스별로 생성되며 다른 클래스에서 동일한 문자여 리터럴을 사용할 경우 각각 클래스마다 별도의 문자열 상수풀 생성
 - 자바 버전에 따라 문자열 상수풀의 위치와 구현 방식이 다를 수 있지만, 일반적으로는 Heap 영역 내의 "java.lang.String" 클래스에 위치하게 되어 있습니다.

### StringBuffer, StringBuilder
```text
StringBuffer와 StringBuilder 클래스는 문자열을 저장하는 데 사용되는 클래스로, 동일한 기능을 수행하지만 다음과 같은 차이가 있습니다.

Thread-Safe 여부
StringBuffer는 스레드 안전(thread-safe)한 클래스이며, 멀티 스레드 환경에서 안정적으로 동작합니다. 
이는 StringBuffer가 메서드 호출 시 내부적으로 synchronized 키워드를 사용하기 때문입니다.
반면 StringBuilder는 스레드 안전하지 않은 클래스입니다. 즉, 멀티 스레드 환경에서 안정적으로 동작하지 않을 수 있습니다. 
그러나 synchronized 키워드를 사용하지 않기 때문에 단일 스레드에서는 StringBuffer보다 빠릅니다.

성능
StringBuffer는 스레드 안전성을 보장하기 위해 내부적으로 동기화(synchronization)을 사용하기 때문에 StringBuilder보다 성능이 떨어집니다.
반면 StringBuilder는 스레드 안전성을 보장하지 않기 때문에 동기화(synchronization)를 사용하지 않아 처리 속도가 더 빠릅니다.

사용 용도
따라서, 멀티 스레드 환경에서 안정적인 동작이 필요한 경우에는 StringBuffer를 사용해야 하며, 
단일 스레드 환경이거나 스레드 안정성이 보장되지 않는 경우에는 StringBuilder를 사용하는 것이 적합합니다.
```


### 오토박싱 & 언박싱 (autoboxing & unboxing)
 - 오토박싱 : 기본형 값을 래퍼 클래스의 객체로 자동으로 컴파일러가 변환해주는것
 - 언박싱 : 객체를 기본형으로 자동 자동으로 컴파일러가 변환해주는것

### 날짜와 시간
 - java.util 패키지 : Calendar와 Date -> LocalDate LocalDateTime 나오고 안쓰임
 - LocalDate(날짜) + LocalTime(시간) -> LocalDateTime(날짜 시간)
 - LocalDateTime + 시간대 -> ZonedDateTime
 - 날짜 - 날짜 = Period
 - 시간 - 시간 = Duration
 - Temporal, TemporalAccessor, TemporalAdjuster를 구현한 클래스 : LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Instant
 - TemporalAmount 를 구현한 클래스 : Period, Duration
 - TemporalUnit : 날짜와 시간의 단위를 정의해논 인터페이스 구현체는 ChronoUnit
 - TemporalField : 년월일날짜와 시간의 필드를 정의해놓는것, 열거형 ChronoField가 구현
 - Instant : 에포크 타임 (1970-01-01 00:00:00 UTC)부터 경과된 시간을 나노초 단위로 표현한다.

### SimpleDateFormat, DateTimeFormatter
```text
Java에서 DateTimeFormatter와 SimpleDateFormat은 모두 날짜와 시간을 다양한 형식으로 표현할 수 있도록 지원하는 클래스입니다.
 그러나 두 클래스 간에는 몇 가지 차이점이 있습니다.

SimpleDateFormat 클래스는 Java 1.0에서부터 사용 가능한 클래스이며, Date 객체를 지정된 패턴에 따라 문자열로 포맷팅할 수 있습니다. 
이 클래스는 매우 유연한 기능을 제공하지만, 동시에 스레드 안전하지 않기 때문에 멀티스레드 환경에서는 사용하지 않는 것이 좋습니다.

DateTimeFormatter 클래스는 Java 8에서 소개된 클래스이며, 스레드 안전하게 설계되어 있습니다.
이 클래스는 LocalDate, LocalTime, LocalDateTime 및 ZonedDateTime 객체와 함께 사용하여 날짜와 시간을 표현하는 데 사용됩니다.
또한, DateTimeFormatter는 문자열에서 LocalDate, LocalTime, LocalDateTime 및 ZonedDateTime 객체를 생성하는 데도 사용됩니다.

DateTimeFormatter는 SimpleDateFormat보다 더 유연하게 포맷팅을 처리할 수 있습니다.
 예를 들어, DateTimeFormatter는 시간대, 새로운 달력 시스템 및 로케일별 형식을 지원합니다. 
또한, DateTimeFormatter는 문자열을 파싱하여 LocalDate, LocalTime, LocalDateTime 및 ZonedDateTime 객체로 변환하는 데에도 사용할 수 있습니다.

따라서 Java 8 이상을 사용하는 경우 DateTimeFormatter를 사용하는 것이 좋습니다.
 이전 버전의 Java를 사용해야 하는 경우, SimpleDateFormat를 사용할 수 있지만, 멀티스레드 환경에서 주의해야 합니다.
```

