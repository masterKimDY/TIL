# 자바의정석

### 제네릭
 - 다양한 타압의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다.
 - 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로운이 줄어든다.

### 제네릭 용어
 - class Sample<T> {}
 - Sample<T> : 제네릭 클래스 T의 Sample 또는 T Sample라고 읽는다.
 - T : 타입변수 또는 타입 매개변수 
 - Sample : 원시타입
 - Sample<String> s = new Sample<String>(); // 지정된 String을 매개변수화된 타입 (parameterized type)

### 제한된 제네릭 클래스
 - 제네릭 타입에 extends를 사용하면 특정 타입의 하위타입들만 대입할 수 있게 제한 할 수 있다.
 - FruitBox<T extends Fruit> //Fruit의 하위 타입만 지정가능
 - 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요해도 extends를 사용한다.
 - FruitBox<T extends Eatable>
 - FruitBox<T extends Fruit & Eatable> //여러개도 &로 이어서 사용가능
 - 제네릭 타입이 다른것만으로는 오버로딩이 성립하지 않는다. 제네릭타입은 컴파일러가 컴파일할때만 사용하고 제거해버린다.

### 와일드 카드
 - <? extends T> : 와일드 카드의 상한제한. T와 그 자손들만 가능.
 - <? super T> : 와일드 카드의 하한제한. T와 그 조상들만 가능
 - <?> : 제한없음. 모든타입이 가능 <? extends Object>와 동일
 - 제네릭 클래스와 달리 와일드 카드에는 &를 사용할수없다 <? extends K & V> 사용불가
 - Comparator에는 항상 <? super T>가 습관적으로 따라붙는다. ??

### 제네릭 메서드
 - static <T> void sort(List<T> list, comparator<? super T> c)
 - <T> : 제네릭 타입의 선언 위치는 반환 타입 바로 앞이다.
 - 제네릭 클래스에 정의된 타입 매개변수와 제네릭 메서드의 정의된 타입 매개변수는 전혀 별개의 것이다.

### 열거형 (enums)
 - enum 열거형이름 { 상수명1, 상수명2 }
 - 열거형 생성자는 제어자가 묵시적으로 private이다.
 - 추상메소드도 가질수있다.
```java
enum Operation {
  PLUS {
    public int apply(int x, int y) { return x + y; }
  },
  MINUS {
    public int apply(int x, int y) { return x - y; }
  },
  TIMES {
    public int apply(int x, int y) { return x * y; }
  },
  DIVIDE {
    public int apply(int x, int y) { return x / y; }
  };

  public abstract int apply(int x, int y);
}
```

- 람다식을 이용해서도 정의 가능
```java
enum Operation {
    PLUS((x, y) -> x + y),
    MINUS((x, y) -> x - y),
    TIMES((x, y) -> x * y),
    DIVIDE((x, y) -> x / y);

    private final IntBinaryOperator op;

    Operation(IntBinaryOperator op) {
        this.op = op;
    }

    public int apply(int x, int y) {
        return op.applyAsInt(x, y);
    }
}
```

### EnumSet
```text
 Java에서 EnumSet은 enum 타입을 기반으로 하는 집합(set) 자료구조입니다. EnumSet은 다음과 같은 특징을 가지고 있습니다.
1. 내부적으로 비트 벡터(bit vector)를 이용하여 구현되어 있기 때문에, 성능이 매우 우수합니다.
2. EnumSet은 enum 값들의 집합을 나타내기 때문에, enum의 상수 값만을 원소로 가질 수 있습니다.
    따라서, 다른 타입의 객체를 원소로 가질 수 있는 일반적인 Set과는 차이가 있습니다.
3. EnumSet은 각각의 원소를 상수의 순서와 대응되는 비트 위치에 저장합니다. 따라서, EnumSet의 원소는 순서가 보장됩니다.

EnumSet은 Set 인터페이스를 구현하기 때문에, Set 인터페이스에서 제공하는 다양한 메소드를 사용할 수 있습니다.
또한, EnumSet은 다른 Set 구현체와 마찬가지로 Iterator를 이용하여 집합의 원소를 순회할 수 있습니다.
```


### 애너테이션(annotation)
```text
Java에서 애너테이션(annotation)은 코드에 부가적인 정보를 제공하는 메타데이터(meta-data)입니다.
 너테이션은 @ 기호를 이용하여 표시하며, 클래스, 메소드, 필드 등의 요소에 적용할 수 있습니다.

애너테이션은 다음과 같은 목적으로 사용됩니다.
컴파일러에게 정보를 제공하기 위해 사용됩니다. 애너테이션을 이용하여 컴파일러가 코드를 컴파일할 때, 더욱 정확한 정보를 제공할 수 있습니다.
런타임에 정보를 제공하기 위해 사용됩니다. 애너테이션을 이용하여 런타임에 코드를 분석하거나 처리할 때, 추가적인 정보를 제공할 수 있습니다.
자동 코드 생성을 위해 사용됩니다. 애너테이션을 이용하여 코드 생성 도구를 만들거나 사용할 때, 더욱 정확하고 효율적인 코드를 생성할 수 있습니다.
Java에서는 다양한 종류의 애너테이션을 제공합니다. 예를 들어, 다음과 같은 애너테이션을 사용할 수 있습니다.

@Override: 메소드를 재정의할 때, 해당 메소드가 상위 클래스나 인터페이스에서 정의된 메소드를 재정의하는지 검사합니다.
@Deprecated: 해당 요소가 더 이상 사용되지 않음을 나타냅니다.
@SuppressWarnings: 컴파일러 경고를 무시하도록 지정합니다.
@Retention: 애너테이션 정보가 유지되는 시기를 지정합니다.
@Target: 애너테이션이 적용될 요소를 지정합니다.
@Documented: 애너테이션 정보가 javadoc에 표시됩니다.

애너테이션은 Java의 메타프로그래밍(meta-programming)에 있어서 매우 중요한 역할을 합니다. 
애너테이션을 이용하여 코드를 더욱 강력하게 만들고, 더욱 효율적으로 처리할 수 있습니다.
```

## 메타 애너테이션
 - 애너테이션을 위한 애너테이션 애너테이션을 정의할 때 애너테이션의 적용대상이나 유지기간등을 지정하는데 사용한다.
 - @Target : 애너테이션이 적용가능한 대상을 지정하는데 사용한다.
 - @Retention : 애너테이션이 유지되는 기간을 지정하는데 사용된다.
   - SOURCE : 소스 파일에만 존재 클래스파일에는 존재하지 않음.
   - CLASS : 클래스 파일에존재, 실행시에 사용불가. 기본값
   - RUNTIME : 클래스 파일에 존재, 실행시에 사용가능.

 - @Inherited : 자손클래스에 상속되도록한다.@Inherited 붙은 애너테이션을 조상 클래스에 붙이면 자손클래스도 이 애너테이션이 붙은 것과 같이 인식
 - @@Repeatable : 동일한 애너테이션을 중복해서 사용가능

### 애너테이션 타입 정의하기
 - @interface 애너테이션이름 { int count() default 1; String testName(); } 
 - 애너테이션의 요소는 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가지고, 상속을 통해 구현하지 않아도 된다.
 - 기본값을 가질수 있으며, 기본값이 있는 요수는 애너테이션을 적용할때 값을 지정하지 않으면 기본값이 사용된다.
 - 모든 애너테이션의 조상은 Annotation이다. 인터페이스로 정의되어있음.

### 마커 애너테이션
 - 요소가 하나도 정의되지 않은 애너테이션을 마커 애너테이션이라한다.

### 애너테이션 요소의 규칙
 - 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용된다.
 - ()안에 매개변수를 선언할 수 없다.
 - 예외를 선언할 수 없다.
 - 요소를 타입 매개변수로 정의할 수 없다.


### 프로세스와 쓰레드
 - 프로세스: 운영체제에서 실행되는 독립적인 실행 단위입니다. 
 - 프로세스는 각각 자신의 메모리 공간을 가지고 있으며, 다른 프로세스의 메모리 공간에 직접 접근할 수 없습니다. 
 - 프로세스는 독립적으로 실행되기 때문에, 다른 프로세스의 동작에 영향을 받지 않습니다.

 - 쓰레드: 프로세스 내에서 실행되는 실행 단위입니다. 쓰레드는 하나의 프로세스 내에서 메모리를 공유하며, 여러 개의 쓰레드가 동시에 실행될 수 있습니다.
 - 쓰레드는 프로세스 내에서 생성 및 제거가 가능하며, 각각의 쓰레드는 자신만의 스택(stack)을 가지고 있습니다.
 - 쓰레드는 같은 프로세스 내에서 실행되기 때문에, 서로 다른 쓰레드가 공유하는 자원에 대한 동기화가 필요합니다.

### 멀티쓰레딩의 장단점
 - CPU의 사용률을 향상시킨다.
 - 자원을 보다 효율적으로 사용할 수 있다.
 - 사용자에 대한 응답성이 향상된다.
 - 작업이 분리되어 코드가 간결해진다.
 - 단점 : 멀티쓰레드 프로세스는 여러 쓰레드가 같은 프로세스 내에서 자원을 공유하면서 작업하기 떄문에 발생항수 있는 
 - 동기화, 교착상태 같은 문제를 고려해서 작성해야한다.
 - 교착상태 : 두 쓰레드가 자원을 점유한 상태에서 서로 상태편이 점유한 자원을 사용하려고 기다리느라 진행이 멈춰있는 상태를 말한다.

### 쓰레드 구현과 실행
 - Java에서는 멀티스레드(multithreading)를 지원합니다. Java에서 쓰레드는 Thread 클래스를 상속받거나, 
 - Runnable 인터페이스를 구현하여 생성할 수 있습니다. 쓰레드를 생성하고 실행하기 위해서는 다음과 같은 메소드를 사용합니다.
 - 쓰레드의 실행순서는 OS의 스케쥴러가 작성한 스케쥴에 의해 결정된다.
```java
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getId());
                System.out.println(Thread.currentThread().getName());
                System.out.println("runable");
            }
        };

        Thread thread = new Thread(runnable, "threadName");
        thread.start();
    }
```

### start()와 run()
 - 쓰레드를 실행시킬 때 run()이 아닌 start()를 호출한다는것
 - run()을 호출하는것은 생성된 쓰레드를 실행시키는것이 아니라 단순히 클래스에 선언된 메서드를 호출하는 것뿐이다.
 - 반면에 start()는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택(call stack)을 생성한 다음에 run()을 호출해서 생성된 호출스택에 run()이 첫번째로 올라가게한다.
 - 모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하기 떄문에, 
 - 새로운 쓰레드를 생성하고 실행시킬 때마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출 스택은 소멸된다.
 - 실행중인 사용자 쓰레드가 하나도 없을 떄 프로그램은 종료된다.

### 싱글쓰레드와 멀티쓰레드
 - 프로세스 또는 쓰레드 간의 작업전황을 컨텍스트 스위칭이라고한다.
```text
컨텍스트 스위칭(Context Switching)은 운영체제에서 여러 프로세스나 쓰레드가 동시에 실행될 때, 
CPU가 실행 중인 작업을 중단하고 다른 작업을 처리하는 과정을 말합니다.

컨텍스트 스위칭은 CPU의 시간을 공유하는 다중 작업(multi-tasking) 시스템에서 중요한 역할을 합니다.
 여러 개의 프로세스나 쓰레드가 동시에 실행될 때, CPU는 각각의 작업에 대해 일정 시간 동안 할당되며, 이러한 할당 과정은 컨텍스트 스위칭을 통해 이루어집니다.

컨텍스트 스위칭은 다음과 같은 순서로 이루어집니다.

현재 실행 중인 작업의 상태를 저장합니다. 이는 CPU 레지스터, 프로세스 또는 쓰레드의 상태, 메모리 등의 정보를 저장하는 것을 말합니다.

다음 실행할 작업의 상태를 로드합니다. 이는 저장된 정보를 다시 불러와서 작업을 계속할 수 있도록 하는 것을 말합니다.

컨텍스트 스위칭은 작업 간 전환이 자주 발생할수록 오버헤드(overhead)가 커집니다. 
따라서, 최적의 성능을 위해서는 컨텍스트 스위칭을 최소화하는 것이 중요합니다. 
이를 위해서는 CPU가 가능한 작업을 최대한 빨리 완료할 수 있도록 코드를 최적화하거나, 
멀티스레드의 동시성을 관리하는 알고리즘 등을 사용하여 컨텍스트 스위칭을 최적화할 수 있습니다.
```
 - 여러 쓰레드가 여러 작업을 동시에 진행하는 것을 병행(concurrent)라고 하고, 하나의 작업을 여러 쓰레드가 나눠서 처리하는 것을 병렬 (parallel)이라 한다.

### 쓰레드의 우선순위
 - 쓰레드는 우선순위 라는 속성을 가지고 있는데, 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다.
 - thread.setPriority(10); //1~10
 - 쓰레드 그룹을 지정하지 않은 쓰레드는 자동적으로 main 쓰레드 그룹에 속하게 된다.

### 데몬 쓰레드 (deamon thread)
 - 데믄쓰레드는 다른 일반쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.
 - 일반 쓰레드가 모두 종료되면 데몬쓰레드는 강제적으로 자동 종료되는데 이유는 데몬 쓰레드는 일반쓰레드의 보조역할을 수행하는 쓰레드이므로 데몬쓰레 존재의미가없어진다.
 - 데몬쓰레드의 예로는 가비지컬렉터, 위드프로세서의 자동저장, 화면자동갱신 등이 있다.

### 쓰레드의 실행제어
 - 쓰레드 프로그래밍이 어려운 이유는 동기화, 스케줄링 때문이다.
 - 효율적인 멀티쓰레드 프로그램을 만들기 위해서는 보다 정교한 스케줄링을 통해 프로세스에게 주어진 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용하도록 해야한다.

### 쓰레드 스케줄링 관련 메서드
```java
void yield(): 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보하고 자신은 실행대기상태가 된다.
void sleep(long millis): 현재 실행 중인 쓰레드를 지정된 시간(밀리초) 동안 멈춥니다.
void join(): 지정된 시간동안 쓰레드가 실행되도록한다. ㅈㅣ정된 시간이 지나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속
void interrupt(): sleep(), join()에 의해 일시정지상태인 쓰레드를 깨워서 실행대기 상태로 만든다. 해당 쓰레드는 인터럽스익셉션이 발생함으로써 일시정지상태를 벗어나게된다.

쓰레드 스케줄링은 JVM(Java Virtual Machine)과 운영체제에 따라 다를 수 있습니다.
따라서, 쓰레드 스케줄링을 제어하는 메서드를 사용할 때는, 운영체제나 JVM에서 지원하는 스케줄링 방식을 고려하여 사용해야 합니다.
또한, 쓰레드 스케줄링을 사용할 때는, 다른 쓰레드와의 상호작용에 대한 동기화(synchronization) 문제에 대해서도 고려해야 합니다.
```

### 쓰레드 상태
 - NEW : 쓰레드가 생성되고 아직 start가 호출되지 않는 상태
 - RUNNABLE : 실행중 또는 실행 가능한 상태
 - BLOCKED : 동기화블럭에 의해서 일시정지된 상태 (lock이 풀릴 때까지 기다리는 상태)
 - WAITING, TIMED_WAITING : 스레드 작업이 종료되지는 않았지만 실행가능하지 않은 일시정지 상태, TIMED_WAITING은 일시정지시간이 지정된 경우를 의미한다.
 - TERMINATED : 종료상태

### 쓰레드의 동기화
 - 멀티쓰레드의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로 작업에 영향을 주게 된다.
 - 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 그래서 도입된 개념이 임계영역과 잠금 이다.
 - 공유 데이터를 사용하는 코드 영역을 임계영역으로 지정해놓고, 공유 데이터가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행 할 수 있게한다.
 - 그리고 해당 쓰레드가 임계영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만 다른 쓰레드가 반납된 lock을 획득하여 임계영역의 코드를 수행할 수 있게 된다.
 - 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는것을 `쓰레드의 동기화`라고 한다.

### synchronized를 이용한 동기화
 - 이 키워드는 임계영역을 설정하는데 사용된다.
 - 모든 객체는 lock을 하나씩 가지고 있으며, 해당 객체의 lock을 가지고 있는 쓰레드만 임계 영역의 코드를 수행할 수 있다.
 - 그리고 다른 쓰레드들은 lock을 얻을 때까지 기다리게 된다.

### wait(), notify()
 - 특정 쓰레드가 객체의 락을 가진 상태로 오랜시간을 보내지 않도록 하는것도 중요하다.
 - 다른 쓰레드들은 모두 해당 객체의 락을 기다리느라 다른 작업들도 원할히 진행되지 않을것이다.
 - 이러한 상황을 개선하기 위해 wait(), notify()이다. 동기화된 임계영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면 일단 wait()을 호출하여 쓰레드가 락을 반납하고 기다리게 한다.
 - 그러면 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할수 있게 된다. 나중에 작업을 진행할 수 있는 상황이 되면 notify()를 호출해서, 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.

### 기아 현상과 경쟁상태
 - 쓰레드는 계속 통지를 받지 못하고 오랫동안 기다리게 되는데 이것을 기아(starvation) 현상이라고 한다.
 - 이 현상을 막으려면, notify()대신 notifyAll()을 사용해야한다. 일단 모든쓰레드에게 통지를하면, 쓰레드는 다시 waiting pool에 들어가더라도 쓰레드는 결국 lock을 얻어 작업을 진행할 수 있다.
 - 여러 쓰레드가 lock을 얻기 위해 서로 경쟁하는것을 경쟁상태 (race condition)이라고 한다.
 - 경쟁 상태를 개선하기 위해서는 쓰레드끼리 구별해서 통지하는것이 필요하다.

### Lock과 condition을 이용한 동기화
 - 동기화 할 수 있는 방법는 synchronized 블럭 외에도 lock클래스를 이용하는 방법이있다.
 - ReentrantLock : 재진입이 가능한 lock, 가장 일반적인 배타 lock
 - ReentrantReadWriteLock : 읽기에는 공유적이고, 쓰기에는 배타적인 lock
 - StampedLock : ReentrantReadWriteLock에 낙관적인 lock의 기능을 추가
```text
Java에서 동기화(Synchronization)를 위해 synchronized 키워드를 이용할 수 있습니다. 
그러나, synchronized는 단일 쓰레드에서 사용하기에는 좋지만, 다중 쓰레드에서 사용할 때는 성능 문제가 발생할 수 있습니다.
이를 보완하기 위해 Java에서는 다음과 같은 락(lock) 클래스를 제공합니다.

ReentrantLock: ReentrantLock은 하나의 쓰레드가 락을 가지고 있을 때, 다른 쓰레드가 락을 획득하려고 할 때 대기 상태로 들어가는 방식을 사용합니다.
ReentrantLock은 lock()과 unlock() 메서드를 이용하여 락을 획득하고 해제합니다.
lock.lock();
try {
    //임계영역
} finally {
    lock.unlock();
}


ReentrantReadWriteLock: ReentrantReadWriteLock은 읽기 전용 락(read lock)과 쓰기 락(write lock)을 제공합니다.
여러 개의 쓰레드가 읽기 전용 락을 획득할 수 있으며, 쓰기 락은 오직 하나의 쓰레드만 획득할 수 있습니다. ReentrantReadWriteLock은 readLock()과 writeLock() 메서드를 이용하여 락을 획득하고 해제합니다.

StampedLock: StampedLock은 읽기 락과 쓰기 락을 제공하며,
 ReentrantReadWriteLock과 달리 쓰기 락이 해제되지 않은 상태에서 읽기 락을 획득할 수 있습니다.
  StampedLock은 readLock(), writeLock(), tryOptimisticRead() 등의 메서드를 이용하여 락을 획득하고 해제합니다.

이러한 락 클래스들은 synchronized보다 더 세밀한 동기화를 가능하게 하며, 성능도 좋습니다. 
그러나, 락 클래스들을 사용할 때는 교착 상태(deadlock) 등의 문제에 대해서 유의해야 합니다. 
또한, ReentrantLock이나 ReentrantReadWriteLock은 단일 쓰레드 환경에서도 사용할 수 있습니다.
```

### volatile
 - 멀티코어 프로세서에서는 코어마다 별도의 캐시를 가지고 있다.
 - 코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다. 다시 같은 값을 읽어올 때는 먼저 캐시에 있는지 확인하고 없을 때만 메모리에서 읽어온다.
 - 그러다보니 도중에 메모리에 저장된 변수의 값이 변경되었는데도 캐시에 저장된 값이 갱신되지 않아서 메모리에 저장된 값이 다른 경우가 발생한다.
 - volatile을 붙이면 코어가 변수의 값을 읽어올때 캐시가 아닌 메모리에서 읽어오기 때문에 캐시와 메모리간의 값의 불일치가 해결된다.
 - synchronized블럭을 사용해도 같은 효과를 얻을수 있다. 쓰레드가 synchronized 블럭으로 들어갈때 나올때 캐시와 메모리간의 동기화가 이루어지기 때문이다.
 - volatile은 해당 변수에 대한 읽거나 쓰기가 원자화된다. 원자화란 것은 작업을 더 이상 누눌수 없게 한다는 의미이다. synchronized블럭도 일종의 원자화라고 할 수 있다.
 - volatile은 변수의 읽거나 쓰기를 원자화 할뿐 동기화하는 것은 아니다.

### fork() join()
 - fork() : 해당 작업을 쓰레드 풀의 작업 큐에 넣는다. 비동기 메서드
 - join() : 해당 작업의 수행이 끝날 때까지 기다렸다가, 수행이 끝나면 그 결과를 반환한다. 동기 메서드