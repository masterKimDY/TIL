# 자바의 정석 

## 자바의정석 챕터 정주행
 - 지역변수는 초기화 해줘야함 -> 스택프레임에 생성되며 메모리는 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 저장된 쓰레기 값이 있을수도


### 기본형 (primitive type)
 - boolean(논리형) (1byte): true, false
 - char(문자형) (2byte): 하나의 문자만 지정 가능 (2byte 유니코드) char c = 'A'; char c = 65;
 - byte (1byte), short (2byte), int (4byte), long (8byte) (정수형) :
 - float (4byte) 부동소수점 사용, double (8byte) (실수형) :
 - 위 8가지 기본형중 boolean을 제외한 7개 기본형은 서로 연산과 변환이 가능

### 참조형 (reference type)
 - 참조형 변수는 null 또는 객체의 주소를 값으로 갖는다. JVM이 32bit면 4byte, 64bit면 8byte가 참조형 변수의 크기

### 상수
 - final 키워드사용
 - 리터럴 : 그 자체로 값을 의미하는 것 
 - 리터럴 타입 접미사: long -> l, L / float -> f, F / double -> d, D
 - 리터럴 앞에 접두사 : 0x, 0X -> 16진수 / 0 -> 8진수 / 0b, 0B -> 2진수 (java 1.7이상) 1_000 처럼 중간에 _ 도 가능 가독성

### 타입 불일치
 - 타입이 달라도 저장 범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용
 - int i = 'A'; 65

### 형식화된 출력 - printf()
 - %n : 줄바꿈 \n을 사용해도 되지만 os마다 줄바꿈 문자가 다를 수 있다. %n이 안전
 - %d : 10진수 정수
 - %o : 8진수 정수
 - %x : 16진수 정수
 - %s : 문자형
 - %b : boolean

### 화면에서 입력받기 - Scanner
```java
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String intputString = scanner.nextLine();
        System.out.println(intputString);
    }
```

### 진법
 - 비트와 바이트 : 2진수를 비트 1비트는 컴퓨터가 값을 저장할 수 있는 최소 단위 / 1비트 8개를 묶으면 바이트
 - 워드(word) : 4byte, 32bit CPU가 한번에 처리 할 수있는 데이터의 크기 (64bit 컴퓨터에서는 64bit임)
 - nibble : 4bit 16진수 1자리
 - 8진법 16진법 : 8진수는 2진수 3자리, 16진수는 2진수 4자리를 한자리로 표현하니 자리수가 짧아져서 알아보기 쉽다.


### 기본형 (primitive type) 문자
  - char (문자) : 문자가 아닌 문자의 유니코드(정수)가 저장됨 0 ~ 65535
  - 인코딩과 디코딩 (encoding & decoding) : 문자를 코드로 변환하는 것 문자인코딩, 반대로 코드를 문자로 변환하는것은 문자 디코딩
  - 아스키(ASCII) : 128개의 문자 집합(character set) 7bit
  - 유니코드(Unicode) : 전세계 모든 문자를 하나의 통일된 문자집합으로 표현 2byte 65536로 표현하려했으나 부족해서 21bit (약 200만 문자)
   유니코드는 유니코드에 포함시키고자 하는 문자들의 집합을 정의하였는데, 이것을 유니코드 문자셋 (캐릭터 셋)이라고 한다.
   그리고 이 문자 셋에 번호를 붙인 것이 유니코드 인코딩이다. 유니코드 인코딩에는 UTF-8, UTF-16, UTF-32 종류 
  자바는 UTF-16을 사용한다 2byte의 고정크기로 표현
 - 코드포인트 : 유니코드 문자셋에 순서대로 붙인 일련번호 U+0061 (코드포인트) = a(유니코드 문자셋) = 0x61(아스키) = 0x0061(UTF-16)


### 기본형 (primitive type) 정수형 byte, short, int, long
 - 부호있는 정수 왼쪽의 첫번째 비트는 부호 비트 (sign bit) 0 -> 0, 양수 / 1 음수
 - n비트로 표현 할 수있는 정수의 개수 : 2n승 byte는 1바이트 8비트 -128 ~ 127
 - JVM의 피연산자 스택(operand stack)이 피연산자를 4byte단위로 저장하기 때문에 크기가 4byte보다 작은 자료형의 값을 계산할 때는 4btye로 변환하여 연산한다. 그래서 int를 사용하는것이 더 효울적
 - 정수형 변수를 선언할 때는 int 타입으로 하고 20억이 넘어서는 long을 사용하자.
 - long 범위도 벗어가면 실수형 타입이나, BigInteger 클래스를 사용하자.
 - 타입이 표현 할 수 있는 값의 범위를 넘어서면 오버플로우 발생 -> byte b = (byte) (127 + 1); -128 / byte b = (byte) (-128 - 1); 127

### 기본형 (primitive type) 실수형 float, double
 - 실수형의 범위와 정밀도 : float(7자리), double(15자리)
 - 실수형은 소수점도 표현해야 하므로 `얼마나 큰 값을 표현할 수 있는가` 뿐만 아니라 얼마나 0에 가깝게 표현할수 있는가도 중요하다.
 - 실수형에서는 오버플로우가 발생하면 변수의 값은 무한대 (infinity)가 된다.
 - 정수형에는 없는 언더플로우가 존재한다. 양의 최소값보다 작은 값이 되는 경우로 값은 0이 된다.
 - 실수형은 오차가 발생할수 있다. 값의 범위뿐만아니라 정밀도도 중요한 요소임.
 - double이라는 이름이 float보다 2배의 정밀도를 갖는다는 의미라함 8byte 15자리 정밀도
 - 실수형은 값을 부동소수점 (floating-point) 형태로 저장한다. +-M x 2E승 값은 형태

 - 부호(S): 0양수 , 1음수 : 2의 보수법을 사용안하므로 0,1만 바꾸면 음수양수
 - 지수(E): double -1023~1024 / float -126~127 (숫자아님, 양의무한대, 음의 무한대 표현을 위한 예약값 존재) 
 - 가수(M): double 10진수로 15자리 정밀도 저장가능 / float 10진수로 7자리 정밀도 저장가능

### 형변환 (casting)
 - 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 형변환 이라한다. (타입) 피연산자
 - 기본형 boolean을 제외한 7가지 타입은 모두 형변환 가능 int(4byte) -> byte(1btye)로 변환시 값에따라 손실이 발생가능
 - int는 약20억 10자리 정밀도 -> float는 10진수 약7자리 정밀도만 제공하므로 int -> float 변환시 정밀도 차이에 의한 오차 발생가능 double 사용
 - 실수형을 정수형으로 변환시 소수점은 버려짐 반올림 X
 - 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.


### 연산자 (operator)
 - 연산자 : 연산을 수행하는 기호 + - * / %
 - 피연산자 : 연산자의 작업 대상 (번수, 상수, 리터럴, 수식)

### 식 (expression)
 - 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것을 식
 - 식을 계산하여 결과를 얻는 것을 식을 평가 (evaluation)
 - 산술 > 비교 > 논리 > 대입 대입은 제일 마지막 수행
 - 단항 > 이항 > 삼항
 - 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽
 
### 산술변환
 - 연산 수행 직전에 발생하는 피연산자의 자동 형변환
 - 두 피연산자의 타입으 같게 일치시킨다 (보다 큰 타입으로 일치).
 - 피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.

### 단항 연산자
 - 증감 연산자 ++ -- :피연산자에 저장된 값을 1증가 또는 감소시킨다.
 - prefix, postfix : 전위형(값이 참조되기 전에 증감시킨다.) 후위형(값이 참조된 후에 증감시킨다.)
```java
    int i = 5;
    int j = 5;
    System.out.println(i++);    //후위형 값을 침조이후 증가시킨다.
    System.out.println(++j);    //전위형 값을 증가이후 참조한다.
```


### 산술 연산자
 - 사칙 연산자 + - * / : 피연산자가 정수형인 경우 0으로 나눌수 없다. 부동소수점인경우는 Infinity로 나눌수없다.
 - int 형간의 나눗셈 : int / int 는 결과가 int

### 문자열 비교
 - equals()

### 효율적인 연산 (short circuit evaluation)
 - true || false -> true 왼쪽이 true면 무조건 true다
 - false && true -> false 왼쪽이 false면 무조건 false다

### 비트 연산자 & | ^ ~ << >>
 - 피연산자를 비트 단위로 논리 연산한다. 피연산자로 실수는 허용하지 않는다.
 - | : 피연산자 중 한쪽의 값이 1이면 1 else 0
 - & : 피연산자 중 양쪽모두 1이어야 1 else 0
 - ^ : 피연산자의 값이 서로 다를때만 1 같을때는 0
 - ~ : 0은1로 1은0으로 비트뒤집기 1의보수 연산자 양의정수 -> 음의정수 (~value + 1) / 음의정수 -> 양의정수 (~(value -1))
 - << : 8 << 2 (2진수 왼쪽으로 2자리 이동시킨다. 빈자리는 0으로 채우고) 32   value * 2의n승  
 - `>>` : -8 >> 2 (오른쪽으로 이동시키기 때문에 부호가 있는 정수는 부호를 ㅇ ㅠ지하기 위해 음수인경우 빈자리 1 양수는 0) -2   value/2의n승
