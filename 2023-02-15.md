# 자바의정성
## 객체지향 언어
 - 코드 재사용성이 높다 : 기존의 코드를 이용하여 쉽게 작성할 수 있다.
 - 코드의 관리가 용이하다 : 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
 - 신뢰성 높은 프로그래밍을 가능하게 한다. : 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록하며, 코드의 중복을 제거한다.


## 클래스 객체의 정의
 - 클래스 객체를 정의해 놓는것, 클래스의 용도 객체를 생성하는데 사용된다.
 - 객체의 정의 실제로 존재하는것 사물 또는 개념, 객체의 용도 객체가 가지고 있는 기능과 속성에 따라 다름

## 객체와 인스턴스
 - 클래스로 부터 객체를 만드는 과정을 클래스의 인스턴스화 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라함.
 - 객체는 모든 인스턴스를 대표하는 포괄적의미, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미
 - 객체의 구성요소 
    - 속성 : **멤버변수**, 특성, 필드, 상태
    - 기능 : **메서드**, 함수, 행위
 - 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.
 - 하나의 참조변수가 여러 인스턴스를 참조는 불가능
 - 데이터 처리를 위한 데이터 저장형태 발전과정 ? : 변수 > 배열 > 구조체 > 클래스
 - String로 문자열을 다룬다 char[]

### 변수와 메서드
 - 선언 위치에 따른 변수 종류
 - 클래스변수 : 클래스 영역에 선언되며 인스턴스변수에 static 키워드가 있다면 클래스변수이다. 공통된 저장공간을 공유한다. (클래스영역 = 메소드영역 = 스테틱 영영)
 - 인스턴스변수 : 클래스 영역에 선언되며 클래스의 인스턴스를 생성할때 만들어진다. 독립적인 저장공간을 가지므로 서로 다른 값 을 가질수있다. (heap)
 - 지역변수 : 멤버변수를 제외한 나머지 변수 (메서드, 생성자 초기화 블럭 내부) (JVM 스택 프레임영역)
```text
인스턴스 변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값으로 유지할수 있다.
클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 같는다.
```

### 메서드
 - 특정 작업을 수행하는 일련의 문자들을 하나로 묶음 것이다.
 - 높은 재사용성 (reuesability) : 한번 만들어 놓은 메서드는 몇번이고 호출할수있으며, 다른 프로그램에서도 사용이 가능하다.
 - 중복된 코드의 제거 : 반복되는 문장들을 묶어서 하나의 메서드로 작성해 놓으면, 메서드를 호출해서 사용할수 있다.
 - 프로그램의 구조화 : 메서드로 나눠서 작성하게되면 프로그램 전체 흐름을 파악하는데 용이하다.

 - 메서드의 선언과 구현 : 반환타입 메서드이름 (타입 변수명, 타입 변수명, .... 매갣변수들) { 메서드 바디 }
 - 메서드 시그니처 : 메소드 이름과 파라미터 
 - 인자(arugument)와 매개변수(parameter) : 메서드를 호출할때 넣는게 인자(argument)인수, 메서드에 선언된게 매개변수(parameter)

### JVM의 메모리 구조
 - 메서드 영역 (method area)
```text
프로그램 실행중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를
이곳에 저장한다. 이때 그 클래스 변수도 이영역에 함께 생성된다.
```
 - 콜스택 (call stack) :
```text
호출 스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을
수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면, 메모리공간은 반환되어 비워진다.
```
 - 힙 (heap) :
```text
인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 인스턴스 변수들이 생성되는 공간이다.
```

```text
 - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당 받는다.
 - 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
 - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
 - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
```

### 기본형 매개변수와 참조형 매개변수
 - 기본형 매개변수 : 값을 읽기만 가능
 - 참조형 매개변수 : 값을 읽고 변경할 수 있다. (불변객체면 어차피 읽기만가능함)

### 재귀호출 (recursive call)
 - 메서드의 내부에서 마서드 자신을 다시 하는것을 재귀호출, 재귀호출을 하는 메서드를 재귀 메서드라한다.
```text
 void method() {
    method(); //무한반복
 }
```
 - 무한반복에 빠지지 않으려면 조건문으로 재귀호출 조건을 걸어줘야한다. (스택에 계속 쌓인다. 스택오버플로우 error)
 ```java
    public static void main(String[] args) {
        int result = factorial(3);
        System.out.println(result);
    }
    public static int factorial(int value) {
        if (value == 1) {
            return value;
        }
        return value * factorial(value -1);
    }
```

## 오버로딩 (overloading)
 - 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 `매개변수의 개수 또는 타입이 다르면` 같은 이름을 사용해서 메서드를 정의할 수 있다.
 - 조건 : 메서드 이름이 같아야한다. 매개변수의 개수 또는 타입이 달라야 한다.
```java
    public static int foo(int i) {
        return i;
    }
    public static int foo() {
        return 0;
    }

    public static int foo(Integer i) {
        return i;
    }
```

### 가변인자 (varargs)와 오버로딩 (overloading)
 - 타입... 변수명 (JDK1.5에 들어옴), 가변인자는 내부적으로 배열을 이용한다.
 - 가능하면 가변인자를 사용한 메서드는 오버로딩 하지 않는 것이 좋다.

### 생성자 (Constructor)
 - 인스턴스가 생성될 때 호출되는 `인스턴스 초기화 메서드` 인스턴스 변수의 초기화 작업에 주로 사용된다. (인스턴스 초기화란 인스턴스 변수들을 초기화 하는 것)
 - 생성자의 이름은 클래스의 이름과 같아야한다. 생성자는 리턴값이 없다.
 - 생성자도 오버로딩이 가능
 - 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
 - default 생성자 : 클래스내에 정의된 생성자가 하나도 없을때 컴파일러가 자동적으로 매개변수(parameter)가 없는 생성자를 하나 생성한다.
 - 생성자에서 다른 생성자 호출하기 : this(...) 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫줄에서만 호출이 가능하다. 
 - 생성자를 이용한 인스턴스 복사 : 인스턴스를 복사하여 생성된것이므로 서로 같은 상태를 갖지만, 서로 독립적으로 메모리공간에 존재하는 별도의 인스턴스이므로 값들이 변경되어도 영향을 받지 않는다.
```java
   public Car(Car copy) {
        this.color = copy.getColor();
        this.door = copy.getDoor();
    }

    Car redCar = new Car("red", 5);
    Car copyRedCar = new Car(redCar);

    redCar.setDoor(4);
    redCar.setColor("black");
```
 - 인스턴스를 생성할때 2가지 고려 사항
 1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
 2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

### 변수의 초기화
 - 멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화 된다. (static 변수 + 인스턴스 변수)

### 멤버 변수 초기화
 - 명시적 초기화 (explicit initialization) : 변수를 선언과 동시에 초기화하는 것을 명시적 초기화 
 - 초기화 블럭 : static { ........... } 클래스 초기화 블럭 (클래스가 메모리에 처음 로딩될 때 한번만 수행) / { .......... } 인스턴스 초기화 블럭 (생성자와 같이 인스턴스를 생성할때마다 수행 생성자보다 먼저수행)
 
### 상속 (inheritance)
 - 상속의 정의와 장점 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는것이다. 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.
 - 조상클래스 : parent class (부모 클래스), super class (상위 클래스)
 - 조상클래스 : child class (자식 클래스), sub class (하위 클래스)
 - class hierarchy (상속계층도)
 - 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다 (멤버변수, 멤버 메소드)
 - 자식 클래스의 인스턴스를 생성하면 조상클래스의 멤버와 자식 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.
 - 클래스간의 관계 - 포함관계 (composite) : 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는것이다.
 - 상속 vs 포함 : Circle `is a` Point (원은 점`이다.`) / Circle `has a` Ponit (원은 점을 `가지고 있다.`)
 - 단일 상속 (single inheritance) : 자바에서는 오직 단일 상속만을 허용한다.

### Object Class (모든 클래스의 조상)
 - 최상위 조상은 Object 클래스이다.
 - Object Class에는 11개의 메서드가 정의되어 있으며, equals(), hashCode(), toString() 추후 더 알아본다.


### 오버라이딩 (overriding)
 - 상위 클래스로부터 상속받은 메서드의 내용을 하위 클래스에서 재정의한다.
 - 오버라이딩 조건 : 이름이 같아야한다. / 매개변수가 같아야한다. / 반환 타입이 같아야한다. (공변 반환타입 반환타입을 자식 클래스의 타입으로 변경하는것)
 - 접근 제어자와 예외는 제한된 조건에서만 다르게 변경 가능 : 접근 제어자는 상위 클래스의 메서드보다 좁은 범위로 변경할수없음, 예외도 마찬가지

### super
 - super는 자식 클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.

### super()
 - 조상 클래스의 생성자 : this()와 마찬가지로 super()도 생성자이다. 조상 클래스의 생성자를 호출하는데 사용된다.
 - 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 한다. 그렇지 않으면 컴파일러는 생성자의 첫 줄에 super();를 자동으로 추가할 것이다.
